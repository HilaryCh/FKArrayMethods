import obspy
from obspy.core.util.geodetics import gps2DistAzimuth, kilometer2degrees, locations2degrees
from obspy import read as read_st
from obspy import read_inventory as read_inv
from obspy import readEvents as read_cat
from obspy.taup import TauPyModel

import numpy
import numpy as np
from numpy import genfromtxt
from numpy import dot
import math
from math import pi
import matplotlib.pyplot as plt
import matplotlib as mpl
import scipy as sp
import scipy.signal as signal
from scipy import sparse


import Muenster_Array_Seismology_Vespagram as MAS
from Muenster_Array_Seismology import get_coords

import os
import datetime

import fk_work
import fk_work as fkw
from fk_work import fk_filter, transpose

def radon_inverse(t,delta,M,p,weights,ref_dist,line_model,inversion_model,hyperparameters):
	#This function inverts move-out data to the Radon domain given the inputs:
	# -t        -- vector of time axis.
	# -delta    -- vector of distance axis.
	# -M        -- matrix of move-out data, ordered size(M)==[length(delta),length(t)].
	# -p        -- vector of slowness axis you would like to invert to.
	# -weights  -- weighting vector that determines importance of each trace.
	#              set vector to ones for no preference.
	# -ref_dist -- reference distance the path-function will shift about.
	#
	# -line_model, select one of the following options for path integration:
	#     'linear'     - linear paths in the spatial domain (default)
	#     'parabolic'  - parabolic paths in the spatial domain.
	#
	# -inversion model, select one of the following options for regularization schema:
	#     'L2'       - Regularized on the L2 norm of the Radon domain (default)
	#     'L1'       - Non-linear regularization based on L1 norm and iterative
	#                  reweighted least sqaures (IRLS) see Sacchi 1997.
	#     'Cauchy'   - Non-linear regularization see Sacchi & Ulrych 1995
	#
	# -hyperparameters, trades-off between fitting the data and chosen damping.
	#
	#Output radon domain is ordered size(R)==[length(p),length(t)].
	#
	#Known limitations:
	# - Assumes evenly sampled time axis.
	# - Assumes move-out data isn't complex.
	#
	#
	# References: Schultz, R., Gu, Y. J., 2012. Flexible Matlab implementation
	#             of the Radon Transform.  Computers and Geosciences [In Preparation]
	#
	#             An, Y., Gu, Y. J., Sacchi, M., 2007. Imaging mantle 
	#             discontinuities using least-squares Radon transform. 
	#             Journal of Geophysical Research 112, B10303.
	#
	# Author: R. Schultz, 2012
	# Translated to Python by: S. Schneider, 2016

	# Define some array/matrices lengths.
	it=len(t)
	iF=math.pow(2,nextpow2(it)+1) # Double length
	iDelta=len(delta)
	ip=len(p)
	iw=len(weights)

	#Exit if inconsistent data is input.
	if not M.shape == (iDelta, it):
		print("Dimensions inconsistent!\nShape of M is not equal to (len(delta),len(t)) \nShape of M = (%i , %i)\n(len(delta),len(t)) = (%i, %i) \n" % (M.shape[0],  M.shape[1], iDelta, it) )
		R=0
		return(R)
	if not iw == iDelta:
		print("Dimensions inconsistent!\nlen(delta) ~= len(weights)\nlen(delta) = %i\nlen(weights) = %i\n" % (iDelta, iw))
		R=0
		return(R)

	#Exit if improper hyperparameters are entered.
	if inversion_model == "L1" or inversion_model == "Cauchy":
		if not len(hyperparameters == 2):
			print("Improper number of trade-off parameters\n")
			R=0
			return(R)
	else: #The code's default is L2 inversion.
		if not len(hyperparameters) == 1:
			print("Improper number of trade-off parameters\n")
			R=0
			return(R)

	#Preallocate space in memory.
	R=np.zeros((ip,it)) #ok<NASGU>
	Rfft=np.zeros((ip,iF))
	A=np.zeros((iDelta,ip))
	Tshift=A
	AtA=np.zeros((ip,ip))
	AtM=np.zeros((ip,1))
	Ident=np.identity(ip)
	
	#Define some values
	Dist_array=delta-ref_dist
	dF=1./(t(1)-t(2))
	Mfft=np.fft.fft(M,iF,1)
	W=sparse.spdiags(weights.T, 0, iDelta, iDelta).A
	
	dCOST=0
	COST_curv=0
	COST_prev=0
	
	#Populate ray parameter then distance data in time shift matrix.
	for j in range(iDelta):
		if line_model == "parabolic":
			Tshift[j]=p
		else: #Linear is default
			Tshift[j]=p
	
	for k in range(ip):
		if line_model == 'parabolic':
			Tshift.T[k]=(2. * ref_dist * Tshift.T[k] * Dist_array.T) + (Tshift.T[k] * (Dist_array**2).T)
		else: #Linear is default
			Tshift.T[k]=Tshift.T[k] * Dist_array.T

	# Loop through each frequency.
	for i in range( math.floor((iF+1)/2) ):

		# Make time-shift matrix, A.
		f = ((i/iF)*dF)
		A = math.exp( (0+2*j)*pi*f * Tshift )

		# M = A R ---> AtM = AtA R
		# Solve the weighted, L2 least-squares problem for an initial solution.
		AtA = dot( dot(A.T, W), A )
		AtM = dot( dot(A.T, W), Mfft.T[i] )
		mu = abs(np.trace(AtA)) * hyperparameters[0]
		Rfft.T[i] = np.linalg.lstsq((AtA + mu*Ident), AtM)[0]
		
		#Non-linear methods use IRLS to solve, iterate until convergence to solution.
		if inversion_model == "Cauchy" or inversion_model == "L1":
			
			#Initialize hyperparameters.
			b=hyperparameters[1]
			lam=mu*b

			#Initialize cost functions.
			dCOST = float("Inf")
			if inversion_model == "Cauchy":
				COST_prev = np.linalg.norm( Mfft.T[i] - dot(A,Rfft.T[i]), 2 ) + lam*sum( np.log( abs(Rfft.T[i]**2 + b))
			elif inversion_model == "L1":
				COST_prev = np.linalg.norm( Mfft.T[i] - dot(A,Rfft.T[i]), 2 ) + lam*np.linalg.norm( abs(Rfft.T[i]+1), 1 )
			itercount=1
			
			#Iterate until negligible change to cost function.
			while dCost > 0.001 and itercount < 10:
				
				#Setup inverse problem.
				if inversion_model == "Cauchy":
					Q = sparse.spdiags( 1./( abs(Rfft.T[i]**2) + b), 0, ip, ip)
				elif inversion_model == "L1":
					Q = sparse.spdiags( 1./( abs(Rfft.T[i]) + b), 0, ip, ip)
				Rfft.T[i]=np.linalg.lstsq( ( lam * Q + AtA ), AtM )
				
				#Determine change to cost function.
				if inversion_model == "Cauchy":
					COST_cur = np.linalg.norm( Mfft.T[i]-A*Rfft.T[i], 2 ) + lam*sum( np.log( abs(Rfft.T[i]**2 + b )-np.log(b) ) )
				elif inversion_model == "L1":
					COST_cur = np.linalg.norm( Mfft.T[i]-A*Rfft.T[i], 2 ) + lam*np.linalg.norm( abs(Rfft.T[i]+1) + b, 1 )
				dCOST = 2*abs(COST_cur - COST_prev)/(abs(COST_cur) + abs(COST_prev))
				COST_prev = COST_cur
				
				itercount += 1

			#Assuming Hermitian symmetry of the fft make negative frequencies the complex conjugate of current solution.
			if not i == 1:
				Rfft.T[iF-i+1] = Rfft.T[i].conjugate()
	
	R = np.fft.ifftn(Rfft, iF, axes=1)
	R = R.T[0:it]

	return(R)



def nextpow2(i):
	#See Matlab documentary
	n = 1
	count = 0
	while n < abs(i):
		n *= 2
		count+=1
	return count
